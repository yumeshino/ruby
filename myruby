開発環境の起動、停止
立ち上げコマンド
$docker-compose up -d

$docker-compose stop
コンテナの停止

$docker-compose down
コンテナの削除
削除しても再度立ち上げコマンドで立ち上がる


$docker-compose up 
-dをつけない場合、コンテナのログを確認できる
サイトにアクセスした際のログを確認できる
しかし、この状態でCntrl+cで強制終了するとrailsがどのプロセス番号で起動しているのか記録しているserver.pidファイルが残ってしまい、次回の起動に失敗することがある
 A server is already running. Check /app/tmp/pids/server.pid.
->このようなエラーがでたら、pidファイルを削除して再度起動コマンドを実行する

http://localhost:3000/rails/info/routes

biding.pry
単語
ctrl+com+f 検索

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
railsを用いたwebページの作成（rootの設定、controller・viewの作成）
１rootingの設定
rooting設定ファイル:config/routes.rb
rootingの定義はブロック内に記述する
root 'boards#index'
rootは、この環境開発の場合localhost:3000にアクセスがきた場合のrootingを意味する
rootの後ろには処理するcontrollerとmethodを指定する
ここでは、localhost:3000にアクセスが来たら、BoardsControllerクラスのindexメソッドを実行するように定義している

２controllerの作成
controllerファイル:app/conntorollerディレクトリの中に作成する
今回作成するのはBoardsControllerなので、app/controller/boards_controller.rbを作成する
controllerを作成する際は小文字で'controller名_controller.rb'の形で作成する


ファイルの中身の設定
①BoardsControllerクラスを定義
  キャメルケースで記述する
  rootの定義に合わせてクラス名が決まる
②ApplicationControllerの継承
  基本的にcontrollerを定義する際はApplicationControllerを継承する
  これによって定義したクラスがcontrollerとして機能するようになる
③indexmethodの定義
  クラスの中にはrootに指定したようにindexmethodを定義する
  rootで定義したmethodのことをアクションという
  今回の場合だと、このindexmethodのことをboardscontrollerのindexアクションと呼ぶ
class BoardsController < ApplicationController
 def index
 end
end

３viewの作成
app/viewsの下にcontroller名と同じの名前のディレクトリを作成して、その下に各アクションに対応するviewを作成する
今回はboardscontrollerなのでapp/views/boardsディレクトリを作成する
indexアクションが呼び出された場合に使用するviewを作成する
今回はindexアクションンのviewなのでindex.html.erbとなる
このルールに合わせてviewを作成することにより自動的にindex.html.erbの内容がwebページに表示される
webページのコンテンツを表示する処理のことをレンダリングという
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

RailsでBootstrapを導入する

Bootstrapとは？
基本的にwebページのでデザインはHTMLとCSSを使って書くが、Bootstrapwo使用する￥ことにより、１からCSSを書いてデザインを考えて作成する必要がなく、Bootstrapで定義されたデザインやレイアウトの枠組みを取り入れることができる
BootstrapのようなデザインのテンプレートととなるCSSのことをCSSフレームワークと呼ぶ

導入方法
１、gemファイルにBootstrapをインストールする
  gem 'bootstrap','~> 4.0.0'
  gem 'mini_racer'
  gemファイルを変更した際は
  docker-compose buildコマンドをターミナルで実行することでgemファイルのgemがインストールされる

２、application.cssファイルの拡張子を.scssに変更する
app/assets/stylesheets配下にあるapplication.cssをapplication.scssに変更する
application.scssの中の最初から記載されている
require_treeやrequire_selfはBootstrapの動作に影響を与えるため削除する
そして、BootstrapのCSSを読み込むためにインポートの定義を追加する
@import "bootstrap"

３、application.jsファイルを編集する
app/assets/javascripts配下にあるapplication.jsを編集する
元々書いてあるjqueryをjquery3に変更
Bootstrapの機能を使うために下の2行を追加
//= require popper
//= require bootstrap-sprokets
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

Modelファイルの作成

Modelとは？
Modelはデータベースとやり取りを行うクラスのこと
データベースとは何らかの情報（人物の情報や商品の情報など）を集め、データの操作や検索を行えるようにしたもの

マイグレーションファイル
データベースにテーブルを作成したり、既存のテーブルの定義を変更する場合に使用する

作成方法
docker-compose run web bundle exec rails g model board name:string title:string body:text

docker-compose run web・・webサービスのコンテナ内で後ろに続くコマンドを実行することを意味する

bundle exec rails g model・・Railsプロジェクトにインストールされたrailsコマンドを実行する。rails g modelでマイグレーションファイルやモデルのファイルなどが作成される。gはジェネレートの略。

board name:string title:string body:text・・boardは作成するmodel名・boardモデルの作成によってboardsテーブルを作成するマイグレーションファイルが作成される。基本的にモデル名は単数形、テーブル名は複数形というルール。
それ以降はテーブルに作成するカラム:カラムの型
ここではString型のnameカラム、String型のtitleカラム、Text型のbodyカラムを作成している



マイグレーションファイルの確認
マイグレーションファイルはdb/migrateディレクトリーの下に作成される。ファイル名にはジェネレートコマンドを実行した日時がつく
マイグレーションファイルにはデータベースにテーブルを作成する為の定義が記載される
マイグレーションファイルとして機能するようにActiveRecord::migrationを継承している
メソッドにはchangeメソッドが定義されており、メソッド内に定義されたテーブルの作成や修正を行うことができ、間違った場合などに元に戻すこともできるメソッド


モデルファイルの確認
モデルファイルはapp/modelsディレクトリーにある
モデルのファイル名を単数形にするのはモデルで共通のルール
ApplicationRecordはモデルとして機能させるために継承されている
モデルにはマイグレーションファイルと違い、カラムの情報は渡されていないが、自動的にboardsテーブルに作成されたカラムのデータを扱うことができる。
命名規則によりboardモデルは、boardsテーブルと関連付いており、boardsテーブルの各レコードをひとつのboardクラスのオブジェクトとして扱うことができる
こういったデータベースの各レコードをデータのORマッパーという


マイグレーションの実行
マイグレーションファイルが作成されただけだとテーブルの作成は行われないのでマイグレーションを実行する
docker-compose run web bundle exec rake db:migrate
このコマンドでまだ未実行のマイグレーションファイルの内容を実行する。今回だとboardsテーブル作成のマイグレーションが実行される
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

RESTfullについて

RESTとは？
・アプリケーションの設計方法の一つ
・HTTPメソッドを使ってwebのリソースを操作する際の設計方法
  →HTTPメソッドとはブラウザでwebページを見る際やフォームを入力したデータを送信する際に裏側でブラウザからサーバーに送信されている命令のこと
・Railsnにおいてリソースとはユーザーや掲示板の情報など、主にデータベースのテーブルのデータのこと


ブラウザから送信するHTTPメソッドと役割
ブラウザから送信できるhttpメソッドはいくつかの種類があるがRails主に使用されるのは以下の4つ
GET・・・・・・リソースの取得/掲示板アプリで言えば掲示板の情報を取得する際にGETメソッドを使用する
POST・・・・・リソースの作成/HTMLのフォームタグを書く際にPOSTメソッドを使用するように指定することでフォームを確定した際にPOSTメソッドでリクエストが送信される
PATCH/PUT・・・リソースの更新/掲示板アプリで言えば一度書き込んだ掲示板の文章を修正する場合などに使用される
DELETE・・・・リソースの削除
webブラウザからサーバーにリクエストを投げる際はこのようにやりたいことによってメソッドを使い分ける
httpメソッドを使用したからリソースの取得やリソースの作成を自動で行ってくれる訳ではなく、どのhttpメソッドでリクエストがきたら何を行うのかを記述するのはプログラマーの仕事

httpメソッドとコントローラー、アクションの対応
httpメソッドとパスの組み合わせでサーバーにリクエストがきてルーティングによってコントローラーのアクションに転送される
（画像）

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

ヘルパーメソッドと<%%>記法について

ヘルパーメソッドとは？
ヘルパーメソッドとはビューの中で使用できるメソッド
ヘルパーを使用することで読みやすい形で、簡潔にHTMLを記述することができる

<% %>とは？
erbのテンプレートファイルにおいては、<% %>で囲った中にはRubのコードを書くことができる。
<%= %>のようにイコールをつけた場合は、Rubyのコードの実行結果をテンプレート（ビュー）内に埋め込むことができる。


ヘルパーメソッドと<%%>記法の一例
<%= form_for board do |f| %>
  <div class="form-group">
    <%= f.label :name, '名前' %>  
    <%= f.text_field :name, class: 'form-control' %>
  </div>
  <div class="form-group">
    <%= f.label :title, 'タイトル' %>
    <%= f.text_field :title, class: 'form-control' %>
  </div>
  <div class="form-group">
    <%= f.label :body, '本文' %>
    <%= f.text_area :body, class: 'form-control', rows: 10 %>
  </div>
   <%= f.submit '保存', class: 'btn btn-primary' %>
<% end %>

  上記のコードで使われているヘルパーメソッドは以下の通り
  form_for・・・・第一引数にはインスタンス変数を指定することでモデルのデータを新規に作成するフォームを作ることができる
  f.label・・・ラベル名の出力を行うメソッド。第一引数にモデルのプロパティ名、第二引数に表示するラベル名を指定する
  f.text_field・・テキストを入力するためのインプット要素を出力している。第一引数にモデルのプロパティ名、第二引数にはハッシュ形式でインプットタグのclass属性を指定する
  f.text_area・・テキストエリアタグを出力している。第一引数は同様にモデルのプロパティ名、第二引数以降はテキストエリアのタグの属性の指定
  f.submit・・submitボタンの作成。第一引数はボタンの表示名、第二引数がボタンタグの属性

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
デバックツールpry-byebugの導入


導入方法
１、gemファイルに追記
開発時のみ必要なgemは、group：developmentのブロック内にgemを追加する
デバックツールが不要な本番環境では余計なgemをインストールせずに済む
gem 'pry-byebug'

２、pry-byebugをインストール
gemを追加したので
$docker-compose build
を実行する

３、コンテナの再起動
gemをインストールしたら
$docker-compose up -d
で一度コンテナを再起動させる


使用方法
dockerの環境でpry-byebugを使用するには Railsコンテナにアタッチして接続する必要があるので、 Railsコンテナ名を確認してからそのコンテナに対してアタッチを実行する

Railsコンテナ名の確認方法
以下のコマンドでコンテナの詳細を確認できる
$docker ps
（画像）

１、コンテナにattachする
コンテナ名が確認できたらアタッチコマンドの後ろにコンテナ名を指定して実行
$docker attach （コンテナ名）
これでpry-byebugを仕込んだ位置でコードをデバックすることができる


２、デバッカーを仕込む
デバックを行いたい位置に以下のコード書く
binding.pry
（画像）
これによりbinding.pryと書いた位置が実行されたタイミングでプログラムが一時停止してデバックを行うことができる

３、コンソールで動作を確認する
コードを記載した画面をweb上で開くか、リロードしてアタッチしたコンソールを確認すると以下のような画面になる
（画像）
binding.pryの位置にきてプログラムが一時停止している状態なのでここで任意のコードを実行することができる
classの内容を確認したり、インスタンス変数を操作したりできる
（画像）

binding.pryをデバックしたい位置に書くことでプログラムの実行を止めて変数の内容を確認したり、値をセットしたりメソッドを呼び出したりといったことが行えるので実際の環境現場でも頻繁に使われるスキル


pry−byebugを止める
デバッカーから抜ける方法
exitかcontinueを実行する
（画像）

アタッチから抜ける方法
Ctrlキーを押しながらp、qの順にキーを押すとアタッチが解除される

binding.pryコードを削除する
binding.pryを書いたままだと画面を表示する度に処理が止まってしまうので使い終わったら忘れずに消すこと
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー









